name: Manage Stale Community Issues

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write

# Prevent race conditions with other community workflows
concurrency:
  group: community-data-updates
  cancel-in-progress: false

jobs:
  manage-stale:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Process stale community issues
        id: stale-check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.staleIssues;

            const themeBacklogPath = 'data/community/theme-backlog.json';
            const factsBacklogPath = 'data/community/facts-backlog.json';
            const proverbsBacklogPath = 'data/community/proverbs-backlog.json';

            let issues = [];
            let page = 1;
            while (true) {
              const { data: pageItems } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: templates.labels.community,
                state: 'open',
                per_page: 100,
                page: page
              });
              issues = issues.concat(pageItems);
              if (!pageItems || pageItems.length < 100) {
                break;
              }
              page += 1;
            }

            const now = new Date();
            const WARNING_THRESHOLD_MS = templates.config.staleWarningAfterMs;   // 12 hours
            const CLOSE_THRESHOLD_MS = templates.config.staleCloseAfterMs;       // 24 hours

            let needsCommit = false;
            let themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
            let facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
            let proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));

            for (const issue of issues) {
              if (!issue.assignees || issue.assignees.length === 0) {
                continue;
              }
              
              const lastActivity = new Date(issue.updated_at);
              const timeSinceActivity = now - lastActivity;
              const hasWarning = issue.labels.some(function(l) { return l.name === templates.labels.staleWarning; });
              
              if (timeSinceActivity >= CLOSE_THRESHOLD_MS) {
                console.log('Closing stale issue #' + issue.number + ': ' + issue.title);
                
                // Unassign the user before closing
                const assignees = issue.assignees.map(function(a) { return a.login; });
                if (assignees.length > 0) {
                  await github.rest.issues.removeAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    assignees: assignees
                  });
                  console.log('Unassigned ' + assignees.join(', ') + ' from issue #' + issue.number);
                }
                
                const closedMsg = t.closed;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: closedMsg.title + ' ' + closedMsg.reason + '\n\n' +
                    closedMsg.reassurance + '\n\n' +
                    closedMsg.footer
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'not_planned'
                });
                
                const title = issue.title;
                
                if (title.includes('Add New Color Theme:')) {
                  // Extract theme name from title like: "[Good First Issue] ðŸŽ¨ Add New Color Theme: Neon Sakura (good first issue)"
                  const themeMatch = title.match(/Add New Color Theme:\s*(.+?)\s*\(good first issue\)/i);
                  if (themeMatch) {
                    const themeName = themeMatch[1].trim();
                    const themeIndex = themes.findIndex(function(t) { return t.name === themeName; });
                    if (themeIndex !== -1 && !themes[themeIndex].completed) {
                      themes[themeIndex].issued = false;
                      needsCommit = true;
                      console.log('Re-enabled theme: ' + themeName);
                    } else if (themeIndex !== -1 && themes[themeIndex].completed) {
                      console.log('Theme "' + themeName + '" is already completed, not re-enabling');
                    }
                  }
                } else if (title.includes('Add Japan Fact #')) {
                  const factIdMatch = title.match(/#(\d+)/);
                  if (factIdMatch) {
                    const factId = parseInt(factIdMatch[1]);
                    const factIndex = facts.findIndex(function(f) { return f.id === factId; });
                    if (factIndex !== -1 && !facts[factIndex].completed) {
                      facts[factIndex].issued = false;
                      needsCommit = true;
                      console.log('Re-enabled fact #' + factId);
                    } else if (factIndex !== -1 && facts[factIndex].completed) {
                      console.log('Fact #' + factId + ' is already completed, not re-enabling');
                    }
                  }
                } else if (title.includes('Add Japanese Proverb #')) {
                  const proverbIdMatch = title.match(/#(\d+)/);
                  if (proverbIdMatch) {
                    const proverbId = parseInt(proverbIdMatch[1]);
                    const proverbIndex = proverbs.findIndex(function(p) { return p.id === proverbId; });
                    if (proverbIndex !== -1 && !proverbs[proverbIndex].completed) {
                      proverbs[proverbIndex].issued = false;
                      needsCommit = true;
                      console.log('Re-enabled proverb #' + proverbId);
                    } else if (proverbIndex !== -1 && proverbs[proverbIndex].completed) {
                      console.log('Proverb #' + proverbId + ' is already completed, not re-enabling');
                    }
                  }
                }
                
              } else if (timeSinceActivity >= WARNING_THRESHOLD_MS && !hasWarning) {
                console.log('Adding warning to issue #' + issue.number);
                
                const warningMsg = t.warning;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: warningMsg.greeting + ' ' + warningMsg.body + '\n\n' +
                    warningMsg.action + '\n\n' +
                    warningMsg.consequence + '\n\n' +
                    warningMsg.footer
                });
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: [templates.labels.staleWarning]
                });
              }
            }

            if (needsCommit) {
              fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
              fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
              fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
              core.setOutput('needs_commit', 'true');
            } else {
              core.setOutput('needs_commit', 'false');
            }

      - name: Commit backlog updates
        if: steps.stale-check.outputs.needs_commit == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add data/community/

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "chore(automation): re-enable stale items in backlog"

          # Pull with rebase and push with retry logic
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES"
            git pull --rebase origin main || git pull --rebase origin master || true
            if git push; then
              echo "Push successful!"
              exit 0
            fi
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Push failed, retrying in 5 seconds..."
              sleep 5
            fi
          done

          echo "Failed to push after $MAX_RETRIES attempts"
          exit 1
